## 2.2.4 
是的。如果其中一个子数组不是有序的，那么其输入顺序将会在输出结果中出现。

## 2.2.5 
2 3 2 5 2 3 2 5 10 2 3 2 5 2 3 2 5 10 20 2 3 2 5 2 3 2 5 10 2 3 2 5 2 2 4 9 19 39  
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4 4 4 4 4 4 4 4 4 3 8 8 8 8 7 16 16 32 39   
程序见Exe2_2_5

## 2.2.6 
见Exe2_2_6

## 2.2.7 
根据书本给出的命题 G 和命题 H（中文版 P173/176，英文版 P275/279），比较次数的下限 C(N) = 1/2 * NlgN  
N 和 lgN 都是单调递增且大于零的(N>1)，因此 C(N) 也是单调递增的

## 2.2.8 
按照题意，如果 a[mid] < a[mid + 1]（左半部分的最后一个元素小于右半部分的第一个元素）  
那么我们可以直接合并数组，不需要再做多余的操作  
唯一的判断为a[mid] < a[mid + 1]，所以有T(N) = 2 T(N/2) + 1,其中 T(1) = 0.  
转化为非递归形式即为：T(N) = cN / 2 + N - 1 其中 c 为任意正整数  

## 2.2.9
代码见merge.java

## 2.2.10
经过按降序将 a[] 的后半部分复制到 aux[]操作，for循环中右边j--，左边i++,就不需要mid作为分割进行遍历aux数组了。  
代码见Exe2_2_10

## 2.2.11 
在 MergeSortX 类里添加一个 CUTOFF 字段，排序时如果数组长度小于它则直接调用插入排序进行排序。  

在调用归并方法前判断第一个有序数组的最后一个元素是否大于第二个有序数组的第一个元素，  
如果大于的话就不需要调用归并了，直接首尾相接即可。  

每次归并都需要两个数组，一个用于存放归并结果，这个数组中的内容是无关紧要的；  另一个则保存了归并前的数组，用于实际的归并过程。  
归并结束后，前一个数组变成归并后的有序结果（也就是下一次归并时的「归并前数组」），后一个数组中的内容则不再有用。  
我们可以看到这两个数组的角色在下一次归并时正好可以互换。  
要注意的是，归并次数总是一个奇数（左侧归并+右侧归并+总归并），因此在第一次调用 Sort 方法时应该把 aux 和 a 互换传入。